
/*QUAKED info_null (0 0.5 0) (-4 -4 -4) (4 4 4)
Used as a positional target for spotlights, etc.
*/
void() info_null =
{
    remove(self);
};

/*QUAKED info_notnull (0 0.5 0) (-4 -4 -4) (4 4 4)
Used as a positional target for lightning.
*/
void() info_notnull =
{
};

//============================================================================

float START_OFF = 1;
float SWITCH_TO_FLICKER = 2; // HONEY
float SWITCH_TO_FADE = 4;    // HONEY

void() light_use =
{
    if(self.spawnflags & START_OFF)
    {
        if(self.spawnflags & SWITCH_TO_FADE){ // HONEY
            self.think = light_fade_in;
            light_fade_in();
        }else{
            lightstyle(self.style, "m");
        }
        self.spawnflags = self.spawnflags - START_OFF;
    }
    else
    {
        if(self.spawnflags & SWITCH_TO_FLICKER) // HONEY
            lightstyle(self.style, "cbaabktsdtbccbrtbklcdfbabcbacacbclkkquakeacbcbcbbklklc");
        else if(self.spawnflags & SWITCH_TO_FADE){
            self.think = light_fade_out;
            light_fade_out();
        }else{
            lightstyle(self.style, "a");
        }
        self.spawnflags = self.spawnflags + START_OFF;
    }
};

/*QUAKED light (0 1 0) (-8 -8 -8) (8 8 8) START_OFF SWITCH_TO_FLICKER SWITCH_TO_FADE
Non-displayed light.
Default light value is 300
Default style is 0
If targeted, it will toggle between on or off.
*/
void() light =
{
    entity e;

    if(!self.targetname)
    {    // inert light
        remove(self);
        return;
    }

    // HONEY
    if(!self.waitmin) { self.waitmin = 0.1; }

    if(self.style >= 32)
    {
        // HONEY
        //make sure there only is ONE light per light style, dunno why :|
        e = find(world, targetname, self.targetname);
        while(e.classname != "light"){
            e = find(e, targetname, self.targetname);
        }

        // HONEY
        if(e.style == self.style && e != self) {
            remove(self);
            return;
        }

        self.use = light_use;
        if(self.spawnflags & START_OFF){
            lightstyle(self.style, "a");

        }else{
            lightstyle(self.style, "m");
            self.cnt = 11; //for fading
        }
    }
};

/*QUAKED light_fluoro (0 1 0) (-8 -8 -8) (8 8 8) START_OFF
Non-displayed light.
Default light value is 300
Default style is 0
If targeted, it will toggle between on or off.
Makes steady fluorescent humming sound
*/
void() light_fluoro =
{
    if(self.style >= 32)
    {
        self.use = light_use;
        if(self.spawnflags & START_OFF)
            lightstyle(self.style, "a");
        else
            lightstyle(self.style, "m");
    }

    precache_sound("ambience/fl_hum1.wav");
    ambientsound(self.origin, "ambience/fl_hum1.wav", 0.5, ATTN_STATIC);
};

/*QUAKED light_fluorospark (0 1 0) (-8 -8 -8) (8 8 8)
Non-displayed light.
Default light value is 300
Default style is 10
Makes sparking, broken fluorescent sound
*/
void() light_fluorospark =
{
    if(!self.style)
        self.style = 10;

    precache_sound("ambience/buzz1.wav");
    ambientsound(self.origin, "ambience/buzz1.wav", 0.5, ATTN_STATIC);
};

/*QUAKED light_globe (0 1 0) (-8 -8 -8) (8 8 8)
Sphere globe light.
Default light value is 300
Default style is 0
*/
void() light_globe =
{
    precache_model("progs/s_light.spr");
    setmodel(self, "progs/s_light.spr");
    makestatic(self);
};

void() FireAmbient =
{
    precache_sound("ambience/fire1.wav");
// attenuate fast
    ambientsound(self.origin, "ambience/fire1.wav", 0.5, ATTN_STATIC);
};

/*QUAKED light_torch_small_walltorch (0 .5 0) (-10 -10 -20) (10 10 20) Quiet
Short wall torch
Default light value is 300
Default style is 0
*/
void() light_torch_small_walltorch =
{
    precache_model("progs/flame.mdl");
    setmodel(self, "progs/flame.mdl");

    if(!(self.spawnflags & 1))
        FireAmbient();

    makestatic(self);
};

/*QUAKED light_flame_large_yellow (0 1 0) (-10 -10 -12) (12 12 18)
Large yellow flame ball
*/
void() light_flame_large_yellow =
{
    precache_model("progs/flame2.mdl");
    setmodel(self, "progs/flame2.mdl");
    self.frame = 1;
    FireAmbient();
    makestatic(self);
};

/*QUAKED light_flame_small_yellow (0 1 0) (-8 -8 -8) (8 8 8) START_OFF
Small yellow flame ball
*/
void() light_flame_small_yellow =
{
    precache_model("progs/flame2.mdl");
    setmodel(self, "progs/flame2.mdl");
    FireAmbient();
    makestatic(self);
};

/*QUAKED light_flame_small_white (0 1 0) (-10 -10 -40) (10 10 40) START_OFF
Small white flame ball
*/
void() light_flame_small_white =
{
    precache_model("progs/flame2.mdl");
    setmodel(self, "progs/flame2.mdl");
    FireAmbient();
    makestatic(self);
};

//============================================================================


/*QUAKED misc_fireball (0 .5 .8) (-8 -8 -8) (8 8 8)
Lava Balls
*/

void() fire_fly;
void() fire_touch;
void() misc_fireball =
{

    precache_model("progs/lavaball.mdl");
    self.classname = "fireball";
    self.nextthink = time + (random() * 5);
    self.think = fire_fly;
    if(!self.speed)
        self.speed = 1000;
};

void() fire_fly =
{
entity    fireball;

    fireball = spawn();
    fireball.solid = SOLID_TRIGGER;
    fireball.movetype = MOVETYPE_TOSS;
    fireball.velocity = '0 0 1000';
    fireball.velocity_x = (random() * 100) - 50;
    fireball.velocity_y = (random() * 100) - 50;
    fireball.velocity_z = self.speed + (random() * 200);
    fireball.classname = "fireball";
    setmodel(fireball, "progs/lavaball.mdl");
    setsize(fireball, '0 0 0', '0 0 0');
    setorigin(fireball, self.origin);
    fireball.nextthink = time + 5;
    fireball.think = SUB_Remove;
    fireball.touch = fire_touch;

    self.nextthink = time + (random() * 5) + 3;
    self.think = fire_fly;
};


void() fire_touch =
{
    T_Damage(other, self, self, 20);
    remove(self);
};

//============================================================================


void() barrel_explode =
{
    self.takedamage = DAMAGE_NO;
    self.classname = "explo_box";
    // did say self.owner
    T_RadiusDamage(self, self, 160, world);
    sound(self, CHAN_VOICE, "weapons/r_exp3.wav", 1, ATTN_NORM);
    particle2(self.origin, '0 0 0', QVR_PARTICLE_PRESET_EXPLOSION, 1);

    self.origin_z = self.origin_z + 32;
    BecomeExplosion();
};



/*QUAKED misc_explobox (0 .5 .8) (0 0 0) (32 32 64)
TESTING THING
*/

void() misc_explobox =
{
    float    oldz;

    self.solid = SOLID_BBOX;
    self.movetype = MOVETYPE_NONE;
    precache_model("maps/b_explob.bsp");
    setmodel(self, "maps/b_explob.bsp");
    precache_sound("weapons/r_exp3.wav");
    self.health = 20;
    self.th_die = barrel_explode;
    self.takedamage = DAMAGE_AIM;

    self.origin_z = self.origin_z + 2;
    oldz = self.origin_z;
    droptofloor();
    if(oldz - self.origin_z > 250)
    {
        dprint("explobox fell out of level at ");
        dprint(vtos(self.origin));
        dprint("\n");
        remove(self);
    }
};




/*QUAKED misc_explobox2 (0 .5 .8) (0 0 0) (32 32 64)
Smaller exploding box, REGISTERED ONLY
*/

void() misc_explobox2 =
{
    float    oldz;

    self.solid = SOLID_BBOX;
    self.movetype = MOVETYPE_NONE;
    precache_model2("maps/b_exbox2.bsp");
    setmodel(self, "maps/b_exbox2.bsp");
    precache_sound("weapons/r_exp3.wav");
    self.health = 20;
    self.th_die = barrel_explode;
    self.takedamage = DAMAGE_AIM;

    self.origin_z = self.origin_z + 2;
    oldz = self.origin_z;
    droptofloor();
    if(oldz - self.origin_z > 250)
    {
        dprint("explobox fell out of level at ");
        dprint(vtos(self.origin));
        dprint("\n");
        remove(self);
    }
};

//============================================================================

//MED 11/09/96 added lava ball and rocket
void() spikeshooter_use =
{
    entity newmis;
    entity lavaball;

    if(mapname == "e2m3" || // VR: There is a bug in e2m3 where spikeshooters
                            // have spawn flags '256', which is invalid in Q1
                            // but valid (fireball) in DoE.
       mapname == "r1m7" || // VR: There is a bug in r1m7 where spikeshooters
                            // have spawn flags '4', which ends up shooting
                            // rockets instead off nails.
        (self.spawnflags & SPAWNFLAG_SUPERSPIKE) ||
        !(self.spawnflags))
    {
        sound(self, CHAN_VOICE, "weapons/spike2.wav", 1, ATTN_NORM);
        newmis = launch_spike (self.origin, self.movedir);
        newmis.velocity = self.movedir * 500;
        if(self.spawnflags & SPAWNFLAG_SUPERSPIKE)
            newmis.touch = superspike_touch;
    }
    else if(self.spawnflags & SPAWNFLAG_LASER)
    {
        if(!(self.spawnflags & SPAWNFLAG_SILENT))
            sound(self, CHAN_VOICE, "enforcer/enfire.wav", 1, ATTN_NORM);
        newmis = LaunchLaser (self.origin, self.movedir);
        newmis.spawnflags = self.spawnflags;
    }
    else if(self.spawnflags & SPAWNFLAG_FIREBALL)
    {
        newmis = launch_fireball (self.origin, self.movedir);
    }
    else if(self.spawnflags & SPAWNFLAG_LAVABALL)
    {
        if(!(self.spawnflags & SPAWNFLAG_SILENT))
             sound(self, CHAN_VOICE, "misc/spike.wav", 1, ATTN_NORM);
        lavaball = spawn();
        lavaball.movetype = MOVETYPE_FLYMISSILE;
        lavaball.solid = SOLID_BBOX;
        lavaball.classname = "lavaball";
        // set lavaball speed
        lavaball.velocity = self.movedir * 300;
        lavaball.angles = vectoangles(lavaball.velocity);
        lavaball.owner = self;
        lavaball.touch = T_MissileTouch;
        setmodel(lavaball, "progs/lavarock.mdl");
        setsize(lavaball, '-4 -4 -4', '4 4 4');
        setorigin(lavaball, self.origin);
        lavaball.avelocity = '0 0 400';
        lavaball.nextthink = time + 5;
        lavaball.think = SUB_Remove;
    }
    else if(self.spawnflags & SPAWNFLAG_ROCKET)
    {
        if(!(self.spawnflags & SPAWNFLAG_SILENT))
            sound(self, CHAN_VOICE, "weapons/sgun1.wav", 1, ATTN_NORM);
        newmis = W_FireRocket(cVR_MainHand); // TODO VR: (P2) this will spawn particles at the gun position
        newmis.velocity = self.movedir*1000;
        newmis.angles = vectoangles(newmis.velocity);
        setorigin(newmis, self.origin + self.movedir*8);
    }
    else if(self.spawnflags & (SPAWNFLAG_SUPERLAVA | SPAWNFLAG_LAVASKILL | SPAWNFLAG_LAVASPIKE))
    {
        sound(self, CHAN_VOICE, "weapons/spike2.wav", 1, ATTN_NORM);
        newmis = launch_lava_spike (self.origin, self.movedir);
        newmis.velocity = self.movedir * 500;
        if(self.spawnflags & SPAWNFLAG_SUPERLAVA)
            newmis.touch = superlavaspike_touch;
        else if((self.spawnflags & SPAWNFLAG_LAVASKILL) && (skill > 1))
            newmis.touch = superlavaspike_touch;
    }
    else
    {
        if(!(self.spawnflags & SPAWNFLAG_SILENT))
            sound(self, CHAN_VOICE, "weapons/spike2.wav", 1, ATTN_NORM);
        newmis = launch_spike (self.origin, self.movedir);
        newmis.velocity = self.movedir * 500;
        if(self.spawnflags & SPAWNFLAG_SUPERSPIKE)
            newmis.touch = superspike_touch;
    }
};

//MED 11/01/96 added state capability
void() shooter_think =
{
    if(self.state)
    {
        spikeshooter_use();
    }
    self.nextthink = time + self.wait;
    // newmis.velocity = self.movedir * 500;
};


/*QUAKED trap_spikeshooter (0 .5 .8) (-8 -8 -8) (8 8 8) superspike laser lava superlava skilllava fireball
When triggered, fires a spike in the direction set in QuakeEd.
Laser, Lava and SuperLava are only for REGISTERED.
*/

//MED 11/01/96 commented out setmovedir
void() trap_spikeshooter =
{
    SetMovedir();
    self.use = spikeshooter_use;

    if(self.spawnflags & SPAWNFLAG_LASER)
    {
        precache_model2("progs/laser.mdl");
        precache_sound2("enforcer/enfire.wav");
        precache_sound2("enforcer/enfstop.wav");
    }
    else if(self.spawnflags & SPAWNFLAG_LAVASPIKE)
    {
        precache_model2("progs/lspike.mdl");
        precache_sound2("lavagun/snail.wav");        // lava nail gun cooldown
        precache_sound2("weapons/rocket1i.wav");
    }
    else if(self.spawnflags & SPAWNFLAG_SUPERLAVA)
    {
        precache_model2("progs/lspike.mdl");
        precache_sound2("lavagun/snail.wav");        // lava nail gun cooldown
        precache_sound2("weapons/spike2.wav");
    }
    else if(self.spawnflags & SPAWNFLAG_LAVASKILL)
    {
        precache_model2("progs/lspike.mdl");
        precache_sound2("lavagun/snail.wav");        // lava nail gun cooldown
        precache_sound2("weapons/rocket1i.wav");
        precache_sound2("weapons/spike2.wav");
    }
    else if(self.spawnflags & SPAWNFLAG_FIREBALL)
    {
        precache_model("progs/fireball.mdl");
    }
    else if(self.spawnflags & SPAWNFLAG_LAVABALL)
    {
        precache_model("progs/lavarock.mdl");
        precache_sound2("misc/spike.wav");
    }
    else if(self.spawnflags & SPAWNFLAG_ROCKET)
    {
        precache_model("progs/missile.mdl");
        precache_sound("weapons/sgun1.wav");
    }
    else
    {
        precache_sound("weapons/spike2.wav");
    }
}


/*QUAKED trap_shooter (0 .5 .8) (-8 -8 -8) (8 8 8) superspike laser lavaball rocket silent
Continuously fires spikes.
"wait" time between spike (1.0 default)
"nextthink" delay before firing first spike, so multiple shooters can be stagered.
*/
void() trap_shooter =
{
    trap_spikeshooter();

    if(self.wait == 0)
        self.wait = 1;
//MED 11/01/96 added state capability
    self.state = 1;

    self.nextthink = self.nextthink + self.wait + self.ltime;
    self.think = shooter_think;
};

//MED 11/01/96 added new use function
void() trap_shooter_use =
{
    self.state = 1 - self.state;
};
//MED 11/01/96 added new function
/*QUAKED trap_switched_shooter (0 .5 .8) (-8 -8 -8) (8 8 8) superspike laser lavaball rocket silent
Continuously fires spikes.
"wait" time between spike (1.0 default)
"nextthink" delay before firing first spike, so multiple shooters can be stagered.
"state" 0 initially off, 1 initially on. (0 default)
*/
void() trap_switched_shooter =
{
    trap_spikeshooter();

    if(self.wait == 0)
        self.wait = 1;
//MED 11/01/96 added state capability
    self.nextthink = self.nextthink + self.wait + self.ltime;
    self.think = shooter_think;
    self.use = trap_shooter_use;
};


/*
===============================================================================


===============================================================================
*/


/*QUAKED air_bubbles (0 .5 .8) (-8 -8 -8) (8 8 8)

testing air bubbles
*/

void() air_bubbles =
{
    if(deathmatch)
    {
        remove (self);
        return;
    }

    precache_model("progs/s_bubble.spr");

    // HONEY
    if(!self.speed) self.speed = 15;
    if(!self.count) self.count = 20;
    self.count = ceil(self.count);
    if(!self.waitmin) self.waitmin = 1;

    // HONEY
    //cg: changed to make the bubbles toggleable
    self.use = air_bubbles_use;

    self.think = make_bubbles;

    // HONEY
    self.state = self.state & 1;
    if(self.targetname == "" || self.state){
        self.nextthink = time + 1;
        self.state = 1;
    }
};

void() make_bubbles =
{
    entity bubble;

    bubble = spawn();

    // HONEY
    bubble.owner = self;

    setmodel(bubble, "progs/s_bubble.spr");
    setorigin(bubble, self.origin);
    bubble.movetype = MOVETYPE_NOCLIP;
    bubble.solid = SOLID_NOT;

    // HONEY
    bubble.velocity = '0 0 0';
    bubble.velocity_z = self.speed;
    bubble.nextthink = time +  0.5 * random();

    bubble.think = bubble_bob;
    bubble.touch = bubble_remove;
    bubble.classname = "bubble";
    bubble.frame = 0;
    bubble.cnt = 0;
    setsize(bubble, '-8 -8 -8', '8 8 8');

    // HONEY
    self.nextthink = time + self.owner.waitmin + random();

    self.think = make_bubbles;
};

void() bubble_split =
{
    entity    bubble;

    bubble = spawn();

    // HONEY
    bubble.owner = self.owner;

    setmodel(bubble, "progs/s_bubble.spr");
    setorigin(bubble, self.origin);
    bubble.movetype = MOVETYPE_NOCLIP;
    bubble.solid = SOLID_NOT;

    // HONEY
    bubble.velocity = self.velocity;
    bubble.velocity_z = bubble.velocity_z * 0.9;
    bubble.alpha = self.alpha;
    bubble.nextthink = time + 0.5 * random();

    bubble.think = bubble_bob;
    bubble.touch = bubble_remove;
    bubble.classname = "bubble";
    bubble.frame = 1;
    self.frame = 1;

    // HONEY
    self.cnt = bubble.cnt = self.owner.count * 0.5;
    setsize(bubble, '-8 -8 -8', '8 8 8');

    // HONEY
    bubble_bob();
};

void() bubble_remove =
{
    if(other.classname == self.classname)
    {
//        dprint("bump");
        return;
    }
    remove(self);
};

void() bubble_bob =
{
    float rnd1, rnd2, rnd3;
    float        maxz, minz;

    // ROGUE
    // PGM fix - 02/25/97 so bubbles won't go through walls
    rnd1 = pointcontents(self.origin);
    if(rnd1 == CONTENT_SOLID)
        remove(self);
    // PGM fix - 02/25/97 so bubbles pop 2 seconds after leaving water
    else if(rnd1 == CONTENT_EMPTY)
    {
        if(self.cnt < 16)
            self.cnt = 16;
    }

    self.cnt = self.cnt + 1;
    if(self.cnt == ceil(self.count * 0.2)) // HONEY
        bubble_split();
    if(self.cnt >= self.owner.count) { // HONEY
        remove(self);
    }

    rnd1 = self.velocity_x + (-10 + (random() * 20));
    rnd2 = self.velocity_y + (-10 + (random() * 20));
    rnd3 = self.velocity_z + 10 + random() * 10;

    if(rnd1 > 10)
        rnd1 = 5;
    if(rnd1 < -10)
        rnd1 = -5;

    if(rnd2 > 10)
        rnd2 = 5;
    if(rnd2 < -10)
        rnd2 = -5;

    // HONEY
    if(self.owner.speed){
        maxz = self.owner.speed + 15;
        minz = self.owner.speed - 5;
    }else{
        maxz = 30;
        minz = 10;
    }

    // HONEY
    if(rnd3 < minz)
        rnd3 = minz + 5;
    if(rnd3 > maxz)
        rnd3 = maxz - 5;

    self.velocity_x = rnd1;
    self.velocity_y = rnd2;
    self.velocity_z = rnd3;

    // HONEY
    self.nextthink = time  + 0.5 * random();

    self.think = bubble_bob;
};

/*~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>
~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~<~>~*/

/*QUAKED viewthing (0 .5 .8) (-8 -8 -8) (8 8 8)

Just for the debugging level.  Don't use
*/

void() viewthing =

{
    self.movetype = MOVETYPE_NONE;
    self.solid = SOLID_NOT;
    precache_model("progs/player.mdl");
    setmodel(self, "progs/player.mdl");
};


/*
==============================================================================

SIMPLE BMODELS

==============================================================================
*/

void() func_wall_use =
{    // change to alternate textures
    self.frame = 1 - self.frame;
};

/*QUAKED func_wall (0 .5 .8) ?
This is just a solid wall if not inhibitted
*/
void() func_wall =
{
    self.angles = '0 0 0';
    self.movetype = MOVETYPE_PUSH;    // so it doesn't get pushed by anything
    self.solid = SOLID_BSP;
    self.use = func_wall_use;
    setmodel(self, self.model);
};


/*QUAKED func_illusionary (0 .5 .8) ?
A simple entity that looks solid but lets you walk through it.
*/
void() func_illusionary =

{
    self.angles = '0 0 0';
    self.movetype = MOVETYPE_NONE;
    self.solid = SOLID_NOT;
    setmodel(self, self.model);
    makestatic(self);
};

/*QUAKED func_episodegate (0 .5 .8) ? E1 E2 E3 E4
This bmodel will appear if the episode has allready been completed, so players can't reenter it.
*/
void() func_episodegate =

{
    if(!(serverflags & self.spawnflags))
        return;            // can still enter episode

    self.angles = '0 0 0';
    self.movetype = MOVETYPE_PUSH;    // so it doesn't get pushed by anything
    self.solid = SOLID_BSP;
    self.use = func_wall_use;
    setmodel(self, self.model);
};

/*QUAKED func_bossgate (0 .5 .8) ?
This bmodel appears unless players have all of the episode sigils.
*/
void() func_bossgate =

{
    if((serverflags & 15) == 15)
        return;        // all episodes completed
    self.angles = '0 0 0';
    self.movetype = MOVETYPE_PUSH;    // so it doesn't get pushed by anything
    self.solid = SOLID_BSP;
    self.use = func_wall_use;
    setmodel(self, self.model);
};

//============================================================================
/*QUAKED ambient_suck_wind (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_suck_wind =
{
    precache_sound("ambience/suck1.wav");
    ambientsound(self.origin, "ambience/suck1.wav", 1, ATTN_IDLE);
    SUB_Remove();
};

/*QUAKED ambient_drone (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_drone =
{
    precache_sound("ambience/drone6.wav");
    ambientsound(self.origin, "ambience/drone6.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};

/*QUAKED ambient_flouro_buzz (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_flouro_buzz =
{
    precache_sound("ambience/buzz1.wav");
    ambientsound(self.origin, "ambience/buzz1.wav", 1, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_drip (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_drip =
{
    precache_sound("ambience/drip1.wav");
    ambientsound(self.origin, "ambience/drip1.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_comp_hum (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_comp_hum =
{
    precache_sound("ambience/comp1.wav");
    ambientsound(self.origin, "ambience/comp1.wav", 1, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_thunder (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_thunder =
{
    precache_sound("ambience/thunder1.wav");
    ambientsound(self.origin, "ambience/thunder1.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_light_buzz (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_light_buzz =
{
    precache_sound("ambience/fl_hum1.wav");
    ambientsound(self.origin, "ambience/fl_hum1.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_swamp1 (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_swamp1 =
{
    precache_sound("ambience/swamp1.wav");
    ambientsound(self.origin, "ambience/swamp1.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};
/*QUAKED ambient_swamp2 (0.3 0.1 0.6) (-10 -10 -8) (10 10 8)
*/
void() ambient_swamp2 =
{
    precache_sound("ambience/swamp2.wav");
    ambientsound(self.origin, "ambience/swamp2.wav", 0.5, ATTN_STATIC);
    SUB_Remove();
};



//============================================================================

void() noise_think =
{
    self.nextthink = time + 0.5;
    sound(self, 1, "enforcer/enfire.wav", 1, ATTN_NORM);
    sound(self, 2, "enforcer/enfstop.wav", 1, ATTN_NORM);
    sound(self, 3, "enforcer/sight1.wav", 1, ATTN_NORM);
    sound(self, 4, "enforcer/sight2.wav", 1, ATTN_NORM);
    sound(self, 5, "enforcer/sight3.wav", 1, ATTN_NORM);
    sound(self, 6, "enforcer/sight4.wav", 1, ATTN_NORM);
    sound(self, 7, "enforcer/pain1.wav", 1, ATTN_NORM);
};

/*QUAKED misc_noisemaker (1 0.5 0) (-10 -10 -10) (10 10 10)

For optimzation testing, starts a lot of sounds.
*/

void() misc_noisemaker =

{
    precache_sound2("enforcer/enfire.wav");
    precache_sound2("enforcer/enfstop.wav");
    precache_sound2("enforcer/sight1.wav");
    precache_sound2("enforcer/sight2.wav");
    precache_sound2("enforcer/sight3.wav");
    precache_sound2("enforcer/sight4.wav");
    precache_sound2("enforcer/pain1.wav");
    precache_sound2("enforcer/pain2.wav");
    precache_sound2("enforcer/death1.wav");
    precache_sound2("enforcer/idle1.wav");

    self.nextthink = time + 0.1 + random();
    self.think = noise_think;
};
